import ballerina/sql;
import ballerina/io;

public client class SQLClient {

    private final sql:Client dbClient;
    
    private string entityName;
    private sql:ParameterizedQuery tableName;
    private map<FieldMetadata> fieldMetadata;
    private string[] keyFields;

    public function init(string entityName, sql:ParameterizedQuery tableName, map<FieldMetadata> fieldMetadata, string[] keyFields, sql:Client dbClient) returns error? {
        self.entityName = entityName;
        self.tableName = tableName;
        self.fieldMetadata = fieldMetadata;
        self.keyFields = keyFields;
        self.dbClient = dbClient;
    }

    function runInsertQuery(record {} 'object) returns sql:ExecutionResult|error {
        sql:ParameterizedQuery query = sql:queryConcat(
            `INSERT INTO `, self.tableName, ` (`,
            self.getColumnNames(), ` ) `,
            `VALUES `, self.getInsertQueryParams('object)
        );
        return check self.dbClient->execute(query);
    }

    // TODO: handle composite keys
    function runReadByKeyQuery(anydata key) returns record {}|error {
        sql:ParameterizedQuery query = sql:queryConcat(
            `SELECT `, self.getColumnNames(), ` FROM `, self.tableName, ` WHERE `, check self.getGetKeyWhereClauses(key)
        );
        return check self.dbClient->queryRow(query);
    }

    function runReadQuery(map<anydata>|FilterQuery filter) returns stream<record {}, sql:Error?>|error {
        sql:ParameterizedQuery query = sql:queryConcat(`SELECT * FROM `, self.tableName, ` WHERE `);
        if filter is FilterQuery {
            query = sql:queryConcat(query, filter);
        } else {
            query = sql:queryConcat(query, check self.getWhereClauses(filter));
        }
        io:println(query);
        stream<record {}, sql:Error?> resultStream = self.dbClient->query(query);
        return resultStream;
    }

    function runUpdateQuery(record {} 'object, map<anydata>|FilterQuery filter) returns error? {
        sql:ParameterizedQuery query = sql:queryConcat(`UPDATE `, self.tableName, ` SET`, check self.getSetClauses('object), ` WHERE`);
        if filter is FilterQuery {
            query = sql:queryConcat(query, ` `, filter);
        } else {
            query = sql:queryConcat(query, check self.getWhereClauses(filter));
        }
        io:println(query);
        _ = check self.dbClient->execute(query);
    }

    function runDeleteQuery(map<anydata>|FilterQuery filter) returns error? {
        sql:ParameterizedQuery query = sql:queryConcat(`DELETE FROM `, self.tableName, ` WHERE`);
        if filter is FilterQuery {
            query = sql:queryConcat(query, ` `, filter);
        } else {
            query = sql:queryConcat(query, check self.getWhereClauses(filter));
        }
        io:println(query);
        _ = check self.dbClient->execute(query);
    }

    private function getInsertQueryParams(record {} 'object) returns sql:ParameterizedQuery {
        sql:ParameterizedQuery params = `(`;
        string[] keys = self.fieldMetadata.keys();
        int columnCount = 0;
        foreach string key in keys {
            if self.fieldMetadata.get(key).autoGenerated {
                continue;
            }
            if columnCount > 0 {
                params = sql:queryConcat(params, `,`);
            }
            params = sql:queryConcat(params, `${<sql:Value>'object[key]}`);
            columnCount = columnCount + 1;
        }
        params = sql:queryConcat(params, `)`);
        return params;
    }

    private function getColumnNames() returns sql:ParameterizedQuery {
        sql:ParameterizedQuery params = ` `;
        string[] keys = self.fieldMetadata.keys();
        int columnCount = 0;
        foreach string key in keys {
            if self.fieldMetadata.get(key).autoGenerated {
                continue;
            }
            if columnCount > 0 {
                params = sql:queryConcat(params, `, `);
            }
            params = sql:queryConcat(params, stringToParameterizedQuery(self.fieldMetadata.get(key).columnName));
            columnCount = columnCount + 1;
        }
        return params;
    }

    // TODO: handle composite keys (record types)
    private function getGetKeyWhereClauses(anydata key) returns sql:ParameterizedQuery|error {
        map<anydata> filter = {};
        filter[self.keyFields[0]] = key;
        return check self.getWhereClauses(filter);
    }

    function getWhereClauses(map<anydata> filter) returns sql:ParameterizedQuery|error {
        sql:ParameterizedQuery query = ` `;
    
        string[] keys = filter.keys();
        foreach int i in 0 ..< keys.length(){
            if i > 0 {
                query = sql:queryConcat(query, ` AND `);
            }
            query = sql:queryConcat(query, check self.getFieldParamQuery(keys[i]), ` = ${<sql:Value>filter[keys[i]]}`);
        }
        return query;
    }

    function getSetClauses(record {} 'object) returns sql:ParameterizedQuery|error {
        sql:ParameterizedQuery query = ` `;
        string[] keys = 'object.keys();
        foreach int i in 0 ..< keys.length(){
            if i > 0 {
                query = sql:queryConcat(query, `, `);
            }
            query = sql:queryConcat(query, check self.getFieldParamQuery(keys[i]), ` = ${<sql:Value>'object[keys[i]]}`);
        }
        return query;
    }

    function getFieldParamQuery(string fieldName) returns sql:ParameterizedQuery|FieldDoesNotExistError {
        FieldMetadata? fieldMetadata = self.fieldMetadata[fieldName];
        if fieldMetadata is () {
            return <FieldDoesNotExistError>error("Field '" + fieldName + "' does not exist in entity '" + self.entityName + "'.");
        }
        return stringToParameterizedQuery(fieldMetadata.columnName);
    }

    function close() returns error? {
        return self.dbClient.close();
    }
}